"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EcosystemCorrelator = void 0;
/**
 * Ecosystem correlation analysis for crypto assets
 */
class EcosystemCorrelator {
    /**
     * Create a new ecosystem correlator
     * @param config - Configuration for the correlator
     */
    constructor(config = {}) {
        this.timeframe = config.timeframe || '1d';
        this.lookbackPeriod = config.lookbackPeriod || 30;
        this.minCorrelationStrength = config.minCorrelationStrength || 0.7;
    }
    /**
     * Analyze correlations between assets
     * @param assets - List of asset symbols to analyze
     * @returns Correlation analysis results
     */
    async analyzeCorrelation(assets) {
        if (assets.length < 2) {
            throw new Error('At least two assets are required for correlation analysis');
        }
        console.log(`Analyzing correlation between ${assets.join(', ')} over ${this.lookbackPeriod} ${this.timeframe} periods`);
        // In a real implementation, you'd fetch historical data and perform correlation analysis
        // For now, we'll return mock data
        const correlations = [];
        // Generate mock correlations between each pair of assets
        for (let i = 0; i < assets.length; i++) {
            for (let j = i + 1; j < assets.length; j++) {
                const correlation = parseFloat((0.5 + Math.random() * 0.5).toFixed(2));
                if (correlation >= this.minCorrelationStrength) {
                    correlations.push({
                        pair: [assets[i], assets[j]],
                        score: correlation,
                        significance: correlation > 0.8 ? 'strong' : 'moderate'
                    });
                }
            }
        }
        return {
            timeframe: this.timeframe,
            period: this.lookbackPeriod,
            correlations,
            timestamp: new Date().toISOString()
        };
    }
    /**
     * Find assets correlated with a specific asset
     * @param symbol - Asset symbol to find correlations for
     * @param universe - Universe of assets to check against
     * @returns Correlated assets
     */
    async findCorrelatedAssets(symbol, universe) {
        if (!universe.includes(symbol)) {
            universe = [symbol, ...universe];
        }
        const result = await this.analyzeCorrelation(universe);
        // Filter for correlations involving the target symbol
        const targetCorrelations = result.correlations.filter((corr) => corr.pair.includes(symbol));
        // Extract the correlated assets
        const correlatedAssets = targetCorrelations.map((corr) => {
            const otherAsset = corr.pair[0] === symbol ? corr.pair[1] : corr.pair[0];
            return {
                symbol: otherAsset,
                correlation: corr.score,
                significance: corr.significance
            };
        });
        return {
            baseAsset: symbol,
            correlatedAssets,
            timestamp: result.timestamp
        };
    }
}
exports.EcosystemCorrelator = EcosystemCorrelator;
